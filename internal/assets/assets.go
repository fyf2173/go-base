// Code generated by go-bindata. DO NOT EDIT.
// sources:
// ../configs/app.yaml
package asset

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"errors"
	"fmt"
	"golang.org/x/text/encoding/simplifiedchinese"
	"golang.org/x/text/transform"
	"io"
	"io/ioutil"
	"math/rand"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"time"

	"gitlab-ce.k8s.tools.vchangyi.com/common/go-toolbox/helper"
)

func bindataRead(data []byte, name string) ([]byte, error) {
	gz, err := gzip.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	var buf bytes.Buffer
	_, err = io.Copy(&buf, gz)
	clErr := gz.Close()

	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}
	if clErr != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _ConfigsAppYaml = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xd4\x93\xc1\x6e\xd4\x30\x10\x86\xef\x7e\x8a\x91\x72\xee\x26\xed\x42\xab\xf8\x5c\x5e\x81\x6b\x34\x1b\xcf\xa6\x96\x9c\x38\xd8\x4e\x17\xee\x50\xe0\xb0\x70\x58\xa1\x0a\x38\x23\x0e\x48\xb0\x12\x97\x2a\x08\x78\x99\x7a\xb7\x8f\x81\x1c\x6f\xb4\x14\xa1\xde\x7b\x72\xfc\xff\xff\x8c\x3f\x8d\x26\xd8\xb6\x45\x83\x35\x71\xa8\xf4\x41\x2d\x4b\xa3\x0f\x2a\xad\x85\x65\xad\x36\x8e\x43\x9e\xe7\x39\xa3\xe6\x9c\xc3\xe9\xa3\xc7\x8c\x25\x9b\x77\xeb\xcd\xf2\xab\xef\x57\xdb\x8f\x57\xfe\xc5\x77\x26\x66\x9c\x01\x24\xf5\x33\xfb\x44\x31\x80\xe1\x0c\x0a\x40\x72\xf3\xed\x87\xef\x57\xc3\xb7\x21\x14\x51\x05\x38\xd3\xd6\x71\x38\x3c\x3a\x99\x64\x93\x6c\x72\xb8\x53\xe3\x6b\xd3\x69\x76\xbc\x13\x3a\x4b\x86\x83\xd1\xda\x8d\x09\xb4\x76\xa1\x8d\x08\xb5\xd3\x07\x0f\xc7\x9c\x40\x87\x33\xb4\xc4\xa1\x34\xb6\x88\xe8\x63\x4b\xad\x8a\x1a\x9f\x16\xa5\x6e\x1a\x2a\xc3\xa3\x59\xf6\xaf\x27\x85\xa2\x7d\xe0\x28\xfa\x89\xbf\x78\x3f\xa2\x2f\x8c\x74\x74\x6f\xd8\x13\x43\x42\x86\x26\xc3\x19\xb1\xff\x07\x1d\x91\x8f\xa7\x27\xf9\x70\xc5\xce\x9d\xc5\xf0\x1e\x29\x63\x77\x83\xdc\x3d\xc2\xc1\xfd\xdb\x29\x9c\xac\x49\x77\x61\x50\xfb\xc0\x02\xa5\xe3\xe0\x4c\x47\x2c\xd9\x5c\x7e\xf2\xbf\x2f\x99\xd2\xd5\xb0\x51\x10\xef\xdb\xfe\xb3\x7f\xf5\x05\x5a\x6c\x64\x99\xce\xd1\xa1\x4a\xc9\x18\x6d\xd2\x05\x9a\x26\x95\xcd\x5c\xa7\x82\x66\x5d\x95\x3a\x83\x25\x81\x5f\xbf\xbd\xee\xdf\xf8\x9f\x2b\xff\x7a\x19\x4b\xb7\x1f\x9e\xc7\x4e\x7e\x7d\x71\x7d\xb5\xbc\xf9\xb5\xf2\x2f\x7b\x06\xa0\xe8\x9c\x14\x87\xd3\x50\xcc\x00\x02\x9d\x75\x58\xb7\xc5\x5c\x92\x12\xbb\x5f\x22\xa8\x63\xf6\x96\x31\x28\x61\xdf\xc9\x5a\xac\xe8\x96\xb7\xd3\xfe\x04\x00\x00\xff\xff\xb1\x01\x4e\xf4\x59\x03\x00\x00")

func ConfigsAppYamlBytes() ([]byte, error) {
	return bindataRead(
		_ConfigsAppYaml,
		"../configs/app.yaml",
	)
}

func ConfigsAppYaml() (*asset, error) {
	bytes, err := ConfigsAppYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "../configs/app.yaml", size: 857, mode: os.FileMode(420), modTime: time.Unix(1591862402, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"../configs/app.yaml": ConfigsAppYaml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"..": &bintree{nil, map[string]*bintree{
		"configs": &bintree{nil, map[string]*bintree{
			"app.yaml": &bintree{ConfigsAppYaml, map[string]*bintree{}},
		}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

// RandString 指定位数的随机字符串
func RandString(lenNum int) string {
	var chars = []string{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"}
	str := strings.Builder{}
	length := len(chars)
	rand.Seed(time.Now().UnixNano()) //重新播种，否则值不会变
	for i := 0; i < lenNum; i++ {
		str.WriteString(chars[rand.Intn(length)])
	}
	return str.String()
}

// StructToMap 结构体转map
// s=[map&结构体]均可
func StructToMap(s interface{}) map[string]interface{} {
	jsonStr, _ := json.Marshal(s)
	data := make(map[string]interface{})
	helper.Must(json.Unmarshal(jsonStr, &data))
	return data
}

// StructToBuffer 结构体转Buffer
// s=[map|结构体]均可
func StructToBuffer(s interface{}) bytes.Buffer {
	var buf bytes.Buffer
	helper.Must(json.NewEncoder(&buf).Encode(s))
	return buf
}

// MapSetStruct Map赋值结构体
/* 结构体需json字段有对应才能匹配
stu := model.AActionInfo{}
err := asset.MapSetStruct(data,&stu)
*/
func MapSetStruct(s interface{}, stu interface{}) error {
	arr, err := json.Marshal(s)
	err = json.Unmarshal(arr, &stu)
	return err
}

// ListRes 处理list及为空数据
// 返回[]map数组列表
func ListRes(list interface{}) []map[string]interface{} {
	D := make([]map[string]interface{}, 0)
	if list == nil {
		return D
	}
	value := reflect.ValueOf(list)
	if value.Kind() != reflect.Slice && value.Kind() != reflect.Array {
		helper.Must(errors.New("返回数据非list结构"))
	}
	for i := 0; i < value.Len(); i++ {
		D = append(D, StructToMap(value.Index(i).Interface()))
	}
	return D
}

// StrVal  获取变量的字符串值  浮点型 3.0将会转换成字符串3, "3"  非数值或字符类型的变量将会被转换成JSON格式字符串
func StrVal(value interface{}) string {
	var key string
	if value == nil {
		return key
	}

	switch value.(type) {
	case float64:
		ft := value.(float64)
		key = strconv.FormatFloat(ft, 'f', -1, 64)
	case float32:
		ft := value.(float32)
		key = strconv.FormatFloat(float64(ft), 'f', -1, 64)
	case int:
		it := value.(int)
		key = strconv.Itoa(it)
	case uint:
		it := value.(uint)
		key = strconv.Itoa(int(it))
	case int8:
		it := value.(int8)
		key = strconv.Itoa(int(it))
	case uint8:
		it := value.(uint8)
		key = strconv.Itoa(int(it))
	case int16:
		it := value.(int16)
		key = strconv.Itoa(int(it))
	case uint16:
		it := value.(uint16)
		key = strconv.Itoa(int(it))
	case int32:
		it := value.(int32)
		key = strconv.Itoa(int(it))
	case uint32:
		it := value.(uint32)
		key = strconv.Itoa(int(it))
	case int64:
		it := value.(int64)
		key = strconv.FormatInt(it, 10)
	case uint64:
		it := value.(uint64)
		key = strconv.FormatUint(it, 10)
	case string:
		key = value.(string)
	case []byte:
		key = string(value.([]byte))
	default:
		newValue, _ := json.Marshal(value)
		key = string(newValue)
	}
	return key
}

// JonsValType 判断数据对应的json类型用于写表或输出转换
// 		正向转换-仅传入Value时将返回string字符串及json对应的类型Type值
// 		逆向转换-两个参数时为功能Value建议为string类型数据，Type支持：number|bool|json|string
func JonsValType(Value interface{}, Type ...string) (interface{}, string) {
	if Value == nil {
		return fmt.Sprintf("%v", Value), "string"
	}
	if len(Type) > 0 {
		v := fmt.Sprintf("%v", Value)
		t := Type[0]
		switch t {
		case "number":
			s, _ := strconv.ParseFloat(v, 64)
			return s, t
		case "bool":
			s := true
			if v == "" || v == "0" || strings.EqualFold(v, "false") {
				s = false
			}
			return s, t
		case "json": //
			var s interface{}
			err := json.Unmarshal([]byte(v), &s)
			if err != nil {
				return nil, t
			}
			return s, t
		}
		return v, "string"
	}
	v := StrVal(Value)
	switch Value.(type) {
	case float64, float32, int, uint, int8, uint8, int16, uint16, int32, uint32, int64, uint64:
		return v, "number"
	case bool:
		return v, "bool"
	case string, []byte:
		return v, "string"
	default:
		return v, "json"
	}
}

// 任意数值字符转换为数值类型
type allType string

// ToNumber 转换为数值类型
// 		i:=ToNumber("01234556").ToInt()
func ToNumber(str interface{}) allType {
	s := allType(fmt.Sprintf("%v", str))
	return s
}
func (s allType) ToFloat64() float64 {
	v, _ := strconv.ParseFloat(string(s), 64)
	return v
}
func (s allType) ToFloat32() float32 {
	return float32(s.ToFloat64())
}
func (s allType) ToInt64() int64 {
	return int64(s.ToFloat64())
}
func (s allType) ToInt32() int32 {
	return int32(s.ToFloat64())
}
func (s allType) ToInt8() int8 {
	return int8(s.ToFloat64())
}
func (s allType) ToInt16() int16 {
	return int16(s.ToFloat64())
}
func (s allType) ToInt() int {
	return int(s.ToFloat64())
}

//IsMap判断类型是否为map
func IsMap(x interface{}) bool {
	t := fmt.Sprintf("%T", x)
	return strings.HasPrefix(t, "map[")
}

//时间戳转日期时间
func TimestampToDateTime(timestamp int64, Format ...string) string {
	layout := "2006-01-02 15:04:05"
	if len(Format) > 0 {
		layout = Format[0]
	}
	Loc, _ := time.LoadLocation("Asia/Shanghai")
	return time.Unix(timestamp, 0).In(Loc).Format(layout)
}

//RFC3339时间戳转日期时间
func RFC3339ToDateTime(value string, Format ...string) string {
	layout := "2006-01-02 15:04:05"
	if len(Format) > 0 {
		layout = Format[0]
	}
	ts, _ := time.Parse(time.RFC3339, value)
	Loc, _ := time.LoadLocation("Asia/Shanghai")
	return ts.In(Loc).Format(layout)
}

// GBK 转 UTF-8
func GbkToUtf8(s []byte) ([]byte, error) {
	reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())
	d, e := ioutil.ReadAll(reader)
	if e != nil {
		return nil, e
	}
	return d, nil
}

// UTF-8 转 GBK
func Utf8ToGbk(s []byte) ([]byte, error) {
	reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewEncoder())
	d, e := ioutil.ReadAll(reader)
	if e != nil {
		return nil, e
	}
	return d, nil
}

// 判断切片中是否存在对应的needle值
func InArray(haystack interface{}, needle interface{}) bool {
	sVal := reflect.ValueOf(haystack)
	kind := sVal.Kind()
	if kind == reflect.Slice || kind == reflect.Array {
		for i := 0; i < sVal.Len(); i++ {
			if sVal.Index(i).Interface() == needle {
				return true
			}
		}
		return false
	}
	return false
}
